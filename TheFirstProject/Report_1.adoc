// suppress inspection "AsciiDocLinkResolve" for whole file

= Отчёт по первому практическому занятию (23.09.22)

:description: TheFirstProject
:keywords: AsciiDoc
:imagesdir: TheFirstProjectImg
:figure-caption: Рисунок
:table-caption: Таблица

[.notes]
== Создание нового проекта
Для того чтобы создать новый проект в программном обеспечении (ПО) IAR, нажмём на панели инструментов кнопку «Project» -> «Create New Project» (рисунок 1).

.Создание нового проекта
image::Create_the_project.png[width=500]

В силу того, что код любой программы начинается с объявления функции main(), создадим функцию main() на языке программирования С++ и укажем адрес файла, куда сохраним новый проект (рисунок 2).

.Создание функции main() на языке С++
image::Create_main.png[width=500]
--
Таким образом, реализовано создание нового пустого проекта (рисунок 3).

.Новый проект
image::NewProject.png[width=500]
--
<<<
=== Работа с терминалом
Напишем код программы, реализующий прибавление единицы к числу типа int8_t:

[source, c]
#include <iostream>
int main()
{
   std::int8_t i = 128;
   i=i+1;
   std::cout<<(int)i<<std::endl;
   return 0;
}

[.notes]
Выведем результат работы программы, реализующей прибавление единицы к числу типа int8_t, размер которого составляет 1 байт (8 бит), на поле терминала (рисунок 4).

.Вывод результата работы программы в терминал
image::Terminal.png[]

[.notes]
Таким образом, результатом суммы единицы и числа 128 типа int8_t является число -127 типа int32_t, размер которого составляет 4 байта (32 бита).
Диапазон представления целых чисел без знака в формате с фиксированной запятой 8 бит составляет (0...255) в 10-й системе счисления (СС).
Ширина полученного интервала составляет 256 целых чисел. В свою очередь, диапазон целых чисел с учетом знака составляет (-128...127) в 10-й СС.
Ширина полученного интервала, так же, как и в случае с форматом без знака, составляет 256 целых чисел.
Представим проведенные преобразования двоичного кода числа типа int8_t с заданным i = 128 на рисунке 5.

.Преобразование двоичного кода числа 128
image::TransformationCode.png[]

[.notes]
Анализируя данные рисунка 5, отметим, что, поскольку в диапазоне представления целых чисел с учетом знака [-128...127] в 10-й СС
отсутствует заданное в коде положительное число 128, в результате чего происходит переполнение массива и переход к левой границе
массива представления целых чисел с учетом знака, то есть -128, что является дополнительным кодом заданного числа i.
Отрицательные числа представляются в дополнительном коде. Дополнительный код числа получается из прямого путем инвертирования
всех его разрядов и прибавлению к полученному результату единицы. Это же правило справедливо и для обратного преобразования.

[Типы данных]
.Типы данных
[options="header"]
|=====================
|Тип|Количество бит|Диапазон
|unsigned char (без знаковый)|8        |0...255
|signed char (знаковый)|8        |-128...127
|char16_t (символ в кодировке Unicode)|16               |0...65 535
|char32_t (символ в кодировке Unicode)|32               |0...4 294 967 295
|unsigned int (без знаковый)|В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита)|0...65 535 (для 2 байт), 0...4 294 967 295 (для 4 байт)
|signed int (знаковый)|В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита)               |–32 768...32767 (при 2 байтах) или от −2 147 483 648...2 147 483 647 (при 4 байтах)
|float (вещественное число ординарной точности с плавающей точкой)|32               |- 3.4E-38...3.4E+38
|double (вещественное число двойной точности с плавающей точкой)|64               |- 1.7E-308...1.7E+308
|=====================

== Выбор контроллера
[.notes]
Ввиду того, что для программирования микроконтроллера необходимо загрузить код программы в печатную плату, следует изменить настройки созданного проекта под используемый микроконтроллер.
Для настройки проекта нажмём правой кнопкой мыши (ПКМ) по проекту и выберем в выпадающем списке «Options» -> «General Options» -> «Target».
Далее на вкладке «Device» выберем используемый микроконтроллер – ST STM32F411RC. На вкладке «Debugger» выберем Driver "ST-LINK". И на вкладке «ST-LINK» выберем "SWD".

image::STM32F411RC.png[]
image::ST_LINK.png[]
image::SWD.png[]

=== Подключение печатной платы к компьютеру

Подключим используемую печатную плату к USB-разъему компьютера, как показано на рисунке 4.

.Подключение печатной платы к USB-разъему компютера
image::Connecting_of_board.png[]

=== Первая программа на плате
Для проверки работоспособности светодиодов печатной платы загрузим код программы из папки «stm32Labs» -> «Lab1» -> iarproject.ewd.

[source, c++]
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOA
std::uint32_t SystemCoreClock = 16'000'000U;
extern "C"
{
   int __low_level_init(void)
   {
      //Switch on external 16 MHz oscillator
      RCC::CR::HSION::On::Set();
      while (RCC::CR::HSIRDY::NotReady::IsSet())
      {
      }
      //Switch system clock on external oscillator
      RCC::CFGR::SW::Hsi::Set();
      while (!RCC::CFGR::SWS::Hsi::IsSet())
      {
      }
      RCC::APB2ENR::SYSCFGEN::Enable::Set();
      return 1;
   }
}
void delay(int cycles)
{
   for(int i = 0; i < cycles; ++i)
   {
      asm volatile("");
   }
}
int main()
{
   //Подать тактирование на порт А
   RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
   //Подать тактирование на порт С
   RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
   //Порт 5.А на вывод
   GPIOA::MODER::MODER5::Output::Set() ;
   //Порт С.5, С.8, С.9 на вывод
   GPIOC::MODER::MODER5::Output::Set() ;
   GPIOC::MODER::MODER8::Output::Set() ;
   GPIOC::MODER::MODER9::Output::Set() ;
   for(;;)
   {
      GPIOA::ODR::ODR5::High::Set();
      GPIOC::ODR::ODR8::High::Set();
      delay(1000000);
      GPIOA::ODR::ODR5::Low::Set();
      GPIOC::ODR::ODR8::Low::Set();
      delay(1000000);
   }
   return 1;
}

Приведенный код программы, написанный на языке программирования C++ в ПО IAR, реализует последовательное изменение состояний одного светодиода печатной платы с 0 на 1.

image::LED_Conditions_0_1.gif[]

=== _forceinline
_forceinline - это макрос, позволяющий не делать функцию
как реальную, т.е. обычно при вызове функции компилятор идёт
внутрь этой функции и выполняет действия, содержащиеся в ней.
Функция Set() из кода выше описывается функцией, находящейся
в файле "fieldvaluebase.hpp".
И для того, чтобы при отладке вместо функции Set() компилятор
не вставлял содержимое этой функции и прописывается данный макрос.

== Вывод
В ходе практической работы проведено изучение и освоение алгоритма создания нового проекта
в по IAR, а также написание кодов программ, реализующих сумму единицы и числа типа int8_t,
выходящего за диапазон представления целых чисел с учетом знака [-128...127], и последовательного
изменения состояний одного из светодиодов используемой печатной платы соответственно.