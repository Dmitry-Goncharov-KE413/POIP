
= Отчёт по второму практическому занятию (30.09.22)

:description: TheSecondProject
:keywords: AsciiDoc
:imagesdir: TheSecondProjectImg
:figure-caption: Рисунок
:table-caption: Таблица

[.notes]
== Создание программы
Для создания проекта в программном обеспечении (ПО) IAR, воспользуемся кнопкой на панели инструментов «Project» ->
«Create New Project», что приведено на рисунке 1.

.Создание нового проекта
image::Create_the_project.png[]

Создадим пустой проект.
--
Таким образом, появился новый пустой проект.
В силу того, что код любой программы начинается с объявления функции main(), создадим функцию main()
на языке программирования С++ и укажем адрес файла, куда сохраним новый проект. Таким образом, реализовано
создание нового пустого проекта.
--
Ввиду того, что для программирования микроконтроллера необходимо загрузить код программы в печатную плату, следует
изменить настройки созданного проекта под используемый микроконтроллер. Для настройки проекта нажмём правой кнопкой мыши
по проекту и выберем в выпадающем списке «Options» -> «General Options» -> «Target». Далее на вкладке «Device» выберем
используемый микроконтроллер – ST STM32F411RC. На вкладке «Debugger» выберем Driver "ST-LINK".
И на вкладке «ST-LINK» выберем "SWD".

image::STM32F411RC.png[]
image::ST_LINK.png[]
image::SWD.png[]
--
Следующим шагом настроим рабочую область, чтобы появилась возможность писать коментарии на
русском языке. Для этого нажмем правой кнопкой мыши по рабочему полю программы и выберем в
контекстном меню «Character Encoding» -> «More» -> «Russian»:

.Подключение русского языка для коментариев
image::Russian_Language.png[]
--

=== Изменение состояний светодиода с 0 на 1
Для мигания светодиодами понадобятся порты такие порты микроконтроллера, как С.5,С.8 и С.9.
Вследствие необходимости подачи тактирования на порт С необходимо подключить библиотеку с
названием "rccregisters.hpp".
В памяти компилятора проекта записана информация о метонахождении стандартных библиотек,
однако при создании собственных библиотек необходимо указывать путь к их местонахождению во избажение
проблем с компиляцией проекта.
Для указания пути к созданной библиотеке нажмем правой клавишой мыши по проекту
и выберем пункт «Options» -> «C/C++Compiler» -> «Preprocessor»:

image::FilePath.png[]

Для того чтобы подать тактирование на порт С используемого микроконтроллера, пропишем в коде программы:
--
[source, c++]
RCC::AHB1ENR::GPIOCEN::Enable::Set();
--
Далее подключим регистры порта С, для чего добавим библиотеку "gpiocregisters.hpp".
--
Переведём порты С.5, С.8 и С.9 на выход с помощью следующих команд:
[source, c++]
  GPIOC::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();
--
Далее напишем код, который изменяет состояние светодиода (порт С.8) микроконтроллера с логического 0 на логическую 1:
[source, c]
  uint8_t i = 0;
  while(true)
  {
     i++;
     if (i%2==0)
     {
       GPIOC::ODR::ODR8::High::Set(); // светодиод на порту С.8 загорается
     }
     else
     {
        GPIOC::ODR::ODR8::Low::Set();  // светодиод на порту С.8 погасает
     }
  }

Но, поскольку изменение состояний логического 0 и логической 1 светодиода на порту С.8 микроконтроллера происходит
практически мгновенно, необходимо установить задержку, для чего добавим в код программы новую функцию Delay():
[source, c]
void Delay(int delay)
{
  for (int i=0; i<delay;++i)
  {
    volatile int j = i; // без оптимизации, выполняет код просто так как он есть, для того чтобы работала задержка
  }
}

Результирующий код программы:
[source, c]
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
//Функция задержки
void Delay(int delay)
{
    for (int i=0; i<delay;++i)
    {
       volatile int j = i; // без оптимизации, выполняет код просто так как он есть, для того чтобы работала задержка
    }
}
//Главная функция
int main()
{
    //Подать тактирование на порт С
    RCC::AHB1ENR::GPIOCEN::Enable::Set();
    //Порты С.5, С.8 и С.9 перевести в режим вывода
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();
    // Зажечь светодиод на порте С.8
    uint8_t i = 0;
    while(true) // Цикл для бесконечного моргания светодиодом
    {
        i++;
        Delay(1000000); // вызов функции задержки
        if (i%2==0) // условие на загорание / погашение светодиода
        {
            GPIOC::ODR::ODR8::High::Set(); // загорается светодиод на порту С.8
        }
        else
        {
            GPIOC::ODR::ODR8::Low::Set();  // светодиод на порту С.8 погасает
        }
    }
}

--
Добавим в программу порт С.9 микроконтроллера:
[source, c++]
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта C
//Функция задержки
void Delay(int delay)
{
    for (int i=0; i<delay;++i)
    {
        volatile int j = i; // без оптимизации, выполняет код просто так как он есть, для того чтобы работала задержка
    }
}
//Главная функция
int main()
{
    //Подать тактирование на порт С
    RCC::AHB1ENR::GPIOCEN::Enable::Set();
    //Порт в режим вывода перевести С.5, С.8 и С.9
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();
    // Зажечь светодиод на порте С.8
    uint8_t i = 0;
    while(true) // Цикл для бесконечного моргания светодиодом
    {
        i++;
        Delay(1000000); // вызов функции задержки
        if (i%2==0) // условие на загорание / погашение светодиода
        {
            GPIOC::ODR::ODR8::High::Set(); // загорается светодиод
            GPIOC::ODR::ODR9::Low::Set();  // светодиод погасает
        }
        else
        {
            GPIOC::ODR::ODR8::Low::Set();  // светодиод погасает
            GPIOC::ODR::ODR9::High::Set(); // загорается светодиод
        }
    }
}
--

=== Оптимизация в IAR
Для того чтобы настроить уровень оптимизации проекта в ПО IAR необходимо нажать правой кнопкой мыши
по созданному проекту проекту и выбрать в выпадающем меню пункт «Options» -> «C/C++Compiler» ->
«Optimizations» (рисунок 3).

.Настройка уровни оптимизации в IAR
image::Optimization.png[]

Уровень оптимизации отвечает за то, какой код компилятор может оптимизировать, т.е.
пустой код он просто не будет выполнять.
В коде выше в функции задержки Delay(int delay) имеется пустой код, который по сути ничего не делает:
[source, c++]
volatile int j = i;

volatile - ключевое слово языков программирования C/C++, информирующее компилятор о том, что значение переменной может
изменяться извне (не зависимо от работы программы).
--
Если ограничить строку кода "volatile int j = i;" комментарием и поставить уровень оптимизации «High»,
то оба светодиода одновременно будут гореть.
Если снять комментарий со строки "volatile int j = i;", то светодиоды будут мигать последовательно.
--

=== Домашнее задание - «Лестница»
Для реализации программы зят светодиод С.7 и под него написан следующий код:
[source, c++]
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта C
//Функция задержки
void Delay(int delay)
{
  for (int i=0; i<delay;++i)
  {
    volatile int j = i; // без оптимизации, выполняет код просто так как он есть, для того чтобы работала задержка
    // если установить уровень оптимизации «High» и ограничить volatile комментарием, то питание будет подаваться на все
светодиоды
    // с раскоментированным volatile при переключении состояний светодиодов происходит видимая временная задержка
  }
}
//Главная функция
int main()
{
    // Подать тактирование на порт С
    RCC::AHB1ENR::GPIOCEN::Enable::Set();
    // Перевести в режим вывода порты С.7, С.8 и С.9
    GPIOC::MODER::MODER7::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();
    // Зажечь светодиоды
    uint8_t i = 0; // переменная для зажигания и погасания светодиодов
    while(true)// цикл для бесконечного моргания светодиодом
    {
        i++;
        if (i%2==0)  // Условие на загорание / погашение светодиода
        {
            GPIOC::ODR::ODR7::High::Set(); // загорается светодиод на порту С.7
            Delay(2000000);  // Вызов функции задержки
            GPIOC::ODR::ODR8::High::Set(); // загорается светодиод на порту С.8
            Delay(2000000);  // Вызов функции задержки
            GPIOC::ODR::ODR9::High::Set();  // светодиод на порту С.9 погасает
            Delay(2000000);  // Вызов функции задержки
        }
        else
        {
            GPIOC::ODR::ODR7::Low::Set();  // светодиод на порту С.7 погасает
            Delay(2000000);  // Вызов функции задержки
            GPIOC::ODR::ODR8::Low::Set();  // светодиод на порту С.8 погасает
            Delay(2000000);  // Вызов функции задержки
            GPIOC::ODR::ODR9::Low::Set();  // светодиод на порту С.9 погасает
            Delay(2000000);  // Вызов функции задержки
        }
    }
}